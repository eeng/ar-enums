require 'active_record'
require 'metaprogramming_extensions'

module ActiveRecord
  class Enum
    attr_reader :id, :name
    
    def initialize attrs = {}
      @id = attrs.delete(:id).to_i
      @name = attrs.delete(:name).to_s
      @label_method = attrs.delete(:label) || :titleize
      attrs.each do |method, value|
        meta_def(method) { value }
      end
    end
    
    def self.create_from value, values, options
      new case value
      when String, Symbol
        options.merge :id => values.index(value) + 1, :name => value
      when Hash
        value[:id] ||= values.index(value) + 1
        value
      end
    end
    
    def == other
      [id.to_s, name].include?(other.to_s)
    end
    
    def to_s
      name.send @label_method
    end
  end
end

module ArEnums
  def self.included(base)
    base.send :extend, ClassMethods
  end
  
  class EnumField
    attr_reader :name
    
    def initialize name
      @name = name.to_s
    end
    
    def enums_getter
      name.pluralize
    end
    
    def enums_setter
      "#{enums_getter}="
    end
    
    def foreign_key
      "#{name}_id"
    end
  end
  
  module ClassMethods
    # == Inline enumerations from an array of values
    # 
    # This is the simplest case. The values are stored as ordinals in a foreign_key, similar to a belongs_to association. 
    # They are autogenerated starting at 1.
    # 
    #   class TrafficLight < ActiveRecord::Base
    #     enum :state, %w[red green yellow]
    #   end
    # 
    #   tl = TrafficLight.new(:state => :green)
    #   tl.state_id   # => 2    
    #   tl.state      # => #<ActiveRecord::Enum @label_method=:titleize, @name="green", @id=2>
    # 
    # == Inline enumerations from an array of hashes
    # 
    # This allows you to define new columns in the Enum value. If the :id is not specified is generated for you.
    # 
    #   class TrafficLight < ActiveRecord::Base
    #     enum :state, [
    #       { :name => :red, :stop_traffic => true, :rgb => 0xF00 },
    #       { :name => :green, :stop_traffic => false, :rgb => 0x0F0 }
    #     ]
    #   end
    # 
    #   tl = TrafficLight.new(:state => :green)
    #   tl.state_id       # => 2    
    #   tl.stop_traffic   # => false
    #   tl.rgb            # => 0x0F0
    # 
    def enum field_name, values, options = {}
      field = EnumField.new field_name
      enums = create_enums values, options
      define_enums_getter field, enums      
      define_enum_getter_and_setter field, enums      
    end
    
    private
    def create_enums values, options
      values.map { |value| ActiveRecord::Enum.create_from(value, values, options) }
    end
    
    def define_enums_getter field, enums
      define_class_method(field.enums_getter) { enums }
    end
    
    def define_enum_getter_and_setter field, enums
      define_method field.name do
        enums.detect { |enum| enum.id == read_attribute(field.foreign_key) }    
      end                                                                       
      
      define_method "#{field.name}=" do |value|
        write_attribute field.foreign_key, enums.detect { |enum| enum == value }.try(:id)
      end
    end
  end
end

ActiveRecord::Base.send :include, ArEnums